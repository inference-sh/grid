import os
import sys
import logging
import tempfile
import subprocess
import shutil
from typing import Optional, List, Set
from inferencesh import BaseApp, BaseAppInput, BaseAppOutput, File
from pydantic import Field

# Enable logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_files_in_directory(directory: str, exclude_patterns: List[str] = None) -> Set[str]:
    """Get all files in a directory recursively, excluding certain patterns."""
    if not os.path.exists(directory):
        return set()

    exclude_patterns = exclude_patterns or []
    files = set()

    for root, dirs, filenames in os.walk(directory):
        # Skip hidden directories
        dirs[:] = [d for d in dirs if not d.startswith('.')]

        for filename in filenames:
            # Skip hidden files and Python cache files
            if filename.startswith('.') or filename.endswith('.pyc'):
                continue

            filepath = os.path.join(root, filename)

            # Check exclude patterns
            exclude = False
            for pattern in exclude_patterns:
                if pattern in filepath:
                    exclude = True
                    break

            if not exclude:
                files.add(filepath)

    return files


def cleanup_directory(directory: str):
    """Remove all files and subdirectories from a directory."""
    if not os.path.exists(directory):
        return

    try:
        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            if os.path.isfile(item_path) or os.path.islink(item_path):
                os.unlink(item_path)
            elif os.path.isdir(item_path):
                shutil.rmtree(item_path)
        logger.info(f"    üßπ Cleaned directory: {directory}")
    except Exception as e:
        logger.warning(f"    ‚ö†Ô∏è  Failed to clean directory {directory}: {e}")


class AppInput(BaseAppInput):
    """Input schema for Python code executor."""
    code: str = Field(description="Python code to execute")
    timeout: int = Field(
        default=30,
        ge=1,
        le=300,
        description="Execution timeout in seconds (1-300)"
    )
    capture_output: bool = Field(
        default=True,
        description="Whether to capture stdout/stderr output"
    )
    working_dir: Optional[str] = Field(
        default=None,
        description="Optional working directory for code execution"
    )


class AppOutput(BaseAppOutput):
    """Output schema for Python code executor."""
    stdout: str = Field(description="Standard output from code execution")
    stderr: str = Field(description="Standard error from code execution")
    # exit_code: int = Field(description="Exit code (0 = success, non-zero = error)")
    # execution_time: float = Field(description="Execution time in seconds")
    error: Optional[str] = Field(default=None, description="Error message if execution failed")
    files: Optional[List[File]] = Field(default=None, description="Optional list of output files generated by the code")


class App(BaseApp):
    """Python Code Executor App for inference.sh platform."""

    def __init__(self):
        super().__init__()

    async def setup(self, metadata=None):
        """Initialize the Python executor."""
        logger.info("üîß Setting up Python Code Executor...")

        # Verify Python environment
        logger.info(f"    Python version: {sys.version}")
        logger.info(f"    Python executable: {sys.executable}")

        logger.info("‚úÖ Python Code Executor setup complete")

    async def run(self, input_data: AppInput, metadata=None) -> AppOutput:
        """Execute Python code and return results."""
        import time

        try:
            logger.info(f"üêç Executing Python code (timeout: {input_data.timeout}s)")
            logger.info(f"    Code length: {len(input_data.code)} characters")

            start_time = time.time()

            # Create temporary file for the code
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp_file:
                tmp_file.write(input_data.code)
                tmp_file_path = tmp_file.name

            try:
                # Set working directory
                # Track if we created it so we know whether to delete it later
                created_temp_dir = False
                if input_data.working_dir:
                    working_dir = input_data.working_dir
                else:
                    # Create a unique temp directory for this execution
                    working_dir = tempfile.mkdtemp(prefix='pyexec_')
                    created_temp_dir = True

                if not os.path.exists(working_dir):
                    os.makedirs(working_dir, exist_ok=True)

                # Create 'outputs' subdirectory for user convenience
                outputs_dir = os.path.join(working_dir, 'outputs')
                try:
                    os.makedirs(outputs_dir, exist_ok=True)
                    # Verify directory was created successfully
                    if not os.path.isdir(outputs_dir):
                        raise RuntimeError(f"Failed to create outputs directory: {outputs_dir}")

                    # Clean outputs directory to ensure no files persist from previous runs
                    cleanup_directory(outputs_dir)
                    logger.info(f"    üìÅ Outputs directory ready: {outputs_dir}")
                except Exception as e:
                    logger.warning(f"    ‚ö†Ô∏è  Could not create outputs directory: {e}")
                    # Continue execution even if outputs directory creation fails

                # Snapshot files before execution
                files_before = get_files_in_directory(working_dir, exclude_patterns=[tmp_file_path])

                # Execute code using subprocess for better isolation
                result = subprocess.run(
                    [sys.executable, tmp_file_path],
                    capture_output=True,
                    text=True,
                    timeout=input_data.timeout,
                    cwd=working_dir,
                    env=os.environ.copy()
                )

                execution_time = time.time() - start_time

                stdout = result.stdout if input_data.capture_output else ""
                stderr = result.stderr if input_data.capture_output else ""
                exit_code = result.returncode

                # Detect new files created during execution
                files_after = get_files_in_directory(working_dir, exclude_patterns=[tmp_file_path])
                new_files = files_after - files_before

                # Convert new files to File objects
                output_files = []
                for filepath in sorted(new_files):
                    if os.path.isfile(filepath):
                        output_files.append(File(path=filepath))
                        logger.info(f"    üìÑ Found output file: {os.path.relpath(filepath, working_dir)}")

                logger.info(f"‚úÖ Code executed successfully in {execution_time:.2f}s")
                logger.info(f"    Exit code: {exit_code}")
                logger.info(f"    Output length: {len(stdout)} chars")
                logger.info(f"    Files generated: {len(output_files)}")

                return AppOutput(
                    stdout=stdout,
                    stderr=stderr,
                    # exit_code=exit_code,
                    error=None if exit_code == 0 else "Non-zero exit code",
                    files=output_files if output_files else None
                )

            except subprocess.TimeoutExpired:
                execution_time = time.time() - start_time
                error_msg = f"Execution timed out after {input_data.timeout} seconds"
                logger.error(f"‚è±Ô∏è {error_msg}")

                return AppOutput(
                    stdout="",
                    stderr=error_msg,
                    # exit_code=-1,
                    # execution_time=execution_time,
                    error=error_msg,
                    files=None
                )

            finally:
                # Clean up temporary file
                try:
                    os.unlink(tmp_file_path)
                except Exception as e:
                    logger.warning(f"Failed to delete temp file: {e}")

        except Exception as e:
            execution_time = time.time() - start_time if 'start_time' in locals() else 0
            error_msg = f"Execution failed: {str(e)}"
            logger.error(f"‚ùå {error_msg}")

            return AppOutput(
                stdout="",
                stderr=str(e),
                # exit_code=-1,
                # execution_time=execution_time,
                error=error_msg,
                files=None
            )
            
        finally:
            # Clean up temporary directory
            try:
                if created_temp_dir:
                    shutil.rmtree(working_dir)
            except Exception as e:
                logger.warning(f"Failed to delete temp directory: {e}")

